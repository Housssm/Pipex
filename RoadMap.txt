# ğŸ“‹ Feuille de Route - Projet PIPEX (42)

---

## ğŸ¯ Vue d'ensemble

Le projet **pipex** consiste Ã  recrÃ©er le comportement des pipes shell en C en utilisant les appels systÃ¨me Unix. 

**Objectif :** Reproduire cette commande shell
```bash
< file1 cmd1 | cmd2 > file2
```

Avec ton programme : 
```bash
./pipex file1 cmd1 cmd2 file2
```

---

## Phase 1 : Comprendre les concepts (1-2 jours)

### Pourquoi commencer par lÃ  ?
Avant d'Ã©crire une ligne de code, tu dois maÃ®triser les outils.  Pipex est un projet systÃ¨me, pas algorithmique.

### Actions concrÃ¨tes

#### 1. ExpÃ©rimente avec les appels systÃ¨me
CrÃ©e des petits programmes de test : 

- **test_fork.c** : CrÃ©er un processus enfant, afficher les PID
- **test_pipe.c** : CrÃ©er un pipe, Ã©crire d'un cÃ´tÃ©, lire de l'autre
- **test_dup2.c** :  Rediriger stdin/stdout
- **test_execve.c** : ExÃ©cuter `/bin/ls` avec execve

#### 2. Teste manuellement dans le shell
```bash
# Compare les rÃ©sultats
< infile grep "hello" | wc -l > outfile
```

### Ressources
- `man 2 pipe`
- `man 2 fork`
- `man 2 execve`
- `man 2 dup2`
- `man 2 wait`

---

## Phase 2 : Architecture et parsing (2-3 jours)

### Pourquoi ? 
Une bonne architecture Ã©vite de tout refaire plus tard. Le parsing est crucial car `cmd1` peut Ãªtre `"grep -i hello"` (avec des arguments).

### Structure de fichiers suggÃ©rÃ©e

```
pipex/
â”œâ”€â”€ srcs/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ parsing.c       # Parser les commandes et arguments
â”‚   â”œâ”€â”€ process.c       # Gestion des fork/exec
â”‚   â”œâ”€â”€ pipes.c         # Gestion des pipes
â”‚   â”œâ”€â”€ errors.c        # Gestion des erreurs
â”‚   â””â”€â”€ utils.c         # Fonctions utilitaires
â”œâ”€â”€ includes/
â”‚   â””â”€â”€ pipex.h
â””â”€â”€ Makefile
```

### TÃ¢ches

#### 1. Parser les arguments
- VÃ©rifier `argc == 5`
- SÃ©parer les commandes de leurs arguments : `"grep -i test"` â†’ `["grep", "-i", "test", NULL]`
- **Astuce :** Utilise `ft_split` de ta libft

#### 2. GÃ©rer les paths
- Chercher les exÃ©cutables dans `PATH` (variable d'environnement)
- Si `cmd1` = `"ls"`, trouver `/bin/ls`
- **Fonction clÃ© :** `char *get_command_path(char *cmd, char **envp)`

#### 3. Structure de donnÃ©es
```c
typedef struct s_pipex {
    int     pipe_fd[2];
    char    **cmd1_args;
    char    **cmd2_args;
    char    *cmd1_path;
    char    *cmd2_path;
    int     infile_fd;
    int     outfile_fd;
} t_pipex;
```

---

## Phase 3 : ImplÃ©mentation du flux simple (3-4 jours)

### Pourquoi dans cet ordre ?
On commence par le chemin "happy path" sans gestion d'erreur complexe.

### Logique Ã  implÃ©menter

```
Parent process
    â”‚
    â”œâ”€ Ouvrir infile et outfile
    â”œâ”€ CrÃ©er pipe[2]
    â”‚
    â”œâ”€ fork() â†’ Child 1
    â”‚   â”‚
    â”‚   â”œâ”€ dup2(infile_fd, STDIN)
    â”‚   â”œâ”€ dup2(pipe[1], STDOUT)  # Ã‰crit dans le pipe
    â”‚   â”œâ”€ close(pipe[0])          # Ne lit pas
    â”‚   â””â”€ execve(cmd1)
    â”‚
    â”œâ”€ fork() â†’ Child 2
    â”‚   â”‚
    â”‚   â”œâ”€ dup2(pipe[0], STDIN)    # Lit depuis le pipe
    â”‚   â”œâ”€ dup2(outfile_fd, STDOUT)
    â”‚   â”œâ”€ close(pipe[1])           # N'Ã©crit pas
    â”‚   â””â”€ execve(cmd2)
    â”‚
    â””â”€ wait() Ã— 2  # Attendre les deux enfants
```

### Points d'attention

- **Fermer les FD inutilisÃ©s** : Chaque processus doit fermer les FD qu'il n'utilise pas
- **Ordre des fork** :  Les deux enfants peuvent Ãªtre crÃ©Ã©s dans n'importe quel ordre
- **`waitpid()` ou `wait()`** : Attendre que les deux enfants se terminent

### Ordre des opÃ©rations dans chaque child

1.  Faire les `dup2()` nÃ©cessaires
2. Fermer TOUS les file descriptors (pipe, infile, outfile)
3. Execve (ne revient jamais si succÃ¨s)

---

## Phase 4 : Gestion des erreurs (2 jours)

### Pourquoi c'est critique ?
La moitiÃ© des points de pipex viennent de la gestion d'erreur.  Le testeur 42 va essayer de tout casser.

### Erreurs Ã  gÃ©rer

#### 1. Fichiers
- `infile` n'existe pas ou pas de permissions â†’ Message d'erreur mais continue
- `outfile` ne peut pas Ãªtre crÃ©Ã© â†’ Exit avec erreur

#### 2. Commandes
- Commande introuvable :  `"commandeinexistante"` â†’ `command not found`
- Commande sans permission d'exÃ©cution

#### 3. Appels systÃ¨me
- VÃ©rifier TOUS les retours :  `pipe()`, `fork()`, `open()`, `dup2()`
- Si un Ã©choue : libÃ©rer la mÃ©moire et exit proprement

#### 4. Memory leaks
- Pas de leaks mÃªme en cas d'erreur
- Utilise valgrind : `valgrind --leak-check=full ./pipex ... `

### Code type pour les erreurs

```c
if (pipe(pipe_fd) == -1)
    error_exit("pipe failed", data);

if (fork() == -1)
    error_exit("fork failed", data);
```

---

## Phase 5 : Tests intensifs (1-2 jours)

### Pourquoi tester autant ?
Pipex est rÃ©putÃ© pour Ãªtre validÃ© facilement mais Ã©chouer au testeur automatique.

### Batterie de tests

```bash
# Test basique
./pipex infile "ls -l" "wc -l" outfile
< infile ls -l | wc -l > expected
diff outfile expected

# Commande inexistante
./pipex infile "lolcat" "wc -l" outfile

# Fichier inexistant
./pipex nofile "cat" "wc -l" outfile

# Permissions
chmod 000 infile
./pipex infile "cat" "wc -l" outfile

# Commandes complexes
./pipex infile "grep a1" "wc -w" outfile
./pipex Makefile "cat" "cat" out1

# Chemins absolus
./pipex infile "/bin/ls" "/usr/bin/wc -l" outfile

# VÃ©rifier les codes de retour
./pipex infile "false" "true" outfile
echo $?  # Doit correspondre au shell
```

### Testeurs recommandÃ©s

- [pipex_tester](https://github.com/vfurmane/pipex-tester)
- Moulinette_tester (si dispo dans ton campus)
- Tests manuels de comparaison avec le shell

---

## Phase 6 : BONUS (optionnel, 2-3 jours)

### âš ï¸ Ã€ faire SEULEMENT si la partie obligatoire est parfaite

### Bonus 1 : Here_doc

```bash
./pipex here_doc LIMITER cmd1 cmd2 outfile
# Ã‰quivalent Ã  :  cmd1 << LIMITER | cmd2 >> outfile
```

**DiffÃ©rences :**
- Lire depuis stdin jusqu'Ã  trouver LIMITER
- Utiliser `>>` (append) au lieu de `>` pour outfile
- Pas besoin de infile

### Bonus 2 : Pipes multiples

```bash
./pipex infile cmd1 cmd2 cmd3 ...  cmdn outfile
# Ã‰quivalent Ã  : < infile cmd1 | cmd2 | cmd3 | ... | cmdn > outfile
```

**ImplÃ©mentation :**
- Boucle sur les commandes
- CrÃ©er un nouveau pipe pour chaque commande intermÃ©diaire
- GÃ©rer les redirections en chaÃ®ne

### Pourquoi faire les bonus ?

- ComprÃ©hension plus profonde des pipes
- Pratique de la gestion dynamique de processus
- Points supplÃ©mentaires
- **MAIS** : Ne commence QUE si la partie obligatoire est Ã  100%

---

## ğŸ¯ Conseils stratÃ©giques

### 1. Teste au fur et Ã  mesure
- N'attends pas d'avoir tout Ã©crit pour tester
- Compile aprÃ¨s chaque fonction
- VÃ©rifie avec valgrind rÃ©guliÃ¨rement

### 2. Utilise Git
```bash
git init
git add .
git commit -m "Phase 1: parsing done"
git commit -m "Phase 2: basic execution works"
```

### 3. Compare avec le shell
- Ton programme DOIT donner le mÃªme rÃ©sultat que le shell
- MÃªme codes de sortie (`echo $?`)
- MÃªme messages d'erreur (format identique)

### 4. Ne cherche pas la perfection du premier coup
- **Version 1 :** Ã‡a marche
- **Version 2 :** Gestion d'erreur
- **Version 3 :** Optimisation et norme

### 5. Debugging
```bash
# Voir tous les appels systÃ¨me
strace ./pipex infile "ls" "wc" outfile

# Voir les file descriptors ouverts
lsof -p <PID>

# Memory leaks
valgrind --leak-check=full --show-leak-kinds=all ./pipex ... 
```

### 6. Norminette
- VÃ©rifie la norme AVANT de soumettre
- `norminette srcs/ includes/`

### 7. Demande de l'aide
- Pair programming avec un camarade
- Revue de code
- Les pairs de 42 sont une ressource inestimable

---

## â±ï¸ Timeline estimÃ©e

| Phase | DurÃ©e estimÃ©e | Checkpoint |
|-------|---------------|------------|
| Phase 1 :  Concepts | 1-2 jours | Tu comprends fork, pipe, dup2, execve |
| Phase 2 :  Architecture | 2-3 jours | Parsing fonctionne, structure claire |
| Phase 3 :  ImplÃ©mentation | 3-4 jours | Cas simple fonctionne (happy path) |
| Phase 4 : Gestion d'erreurs | 2 jours | Toutes les erreurs gÃ©rÃ©es, pas de crash |
| Phase 5 :  Tests | 1-2 jours | Tous les tests passent |
| **Total partie obligatoire** | **8-12 jours** | **PrÃªt pour Ã©valuation** |
| Phase 6 : Bonus | 2-3 jours | Here_doc + multiple pipes |
| **Total avec bonus** | **10-15 jours** | **125% si tout parfait** |

---

## ğŸ“š Concepts clÃ©s Ã  maÃ®triser

### Appels systÃ¨me essentiels

| Fonction | Usage | Man page |
|----------|-------|----------|
| `pipe()` | CrÃ©er un pipe (2 FD) | `man 2 pipe` |
| `fork()` | CrÃ©er un processus enfant | `man 2 fork` |
| `execve()` | Remplacer le processus par une commande | `man 2 execve` |
| `dup2()` | Dupliquer un FD vers un autre | `man 2 dup2` |
| `wait()` | Attendre la fin d'un enfant | `man 2 wait` |
| `open()` | Ouvrir un fichier | `man 2 open` |
| `close()` | Fermer un FD | `man 2 close` |
| `access()` | VÃ©rifier les permissions | `man 2 access` |

### Le pipe en dÃ©tail

Un pipe est un **buffer FIFO** (First In First Out) avec 2 extrÃ©mitÃ©s :
- `pipe_fd[0]` : lecture (output du pipe)
- `pipe_fd[1]` : Ã©criture (input du pipe)

**RÃ¨gle d'or :** Ferme ce que tu n'utilises pas ! 

### Les file descriptors

- `0` = STDIN
- `1` = STDOUT  
- `2` = STDERR

`dup2(old_fd, new_fd)` : Copie `old_fd` vers `new_fd`

---

## âœ… Checklist finale avant soumission

- [ ] Aucun memory leak (valgrind clean)
- [ ] Norminette OK sur tous les fichiers
- [ ] Makefile avec rÃ¨gles :  all, clean, fclean, re
- [ ] Gestion de toutes les erreurs
- [ ] Messages d'erreur sur STDERR
- [ ] Comparaison avec le shell :  rÃ©sultats identiques
- [ ] Codes de retour corrects
- [ ] Testeurs externes passÃ©s
- [ ] Pas de fonctions interdites
- [ ] LibÃ©ration de toute la mÃ©moire allouÃ©e

---

## ğŸš€ PrÃªt Ã  dÃ©marrer ?

**Prochaine Ã©tape :** Phase 1 - CrÃ©e tes programmes de test ! 

Commence par un simple `test_fork.c` :
```c
#include <unistd.h>
#include <stdio.h>

int main(void)
{
    pid_t pid = fork();
    
    if (pid == 0)
        printf("Je suis l'enfant (PID: %d)\n", getpid());
    else
        printf("Je suis le parent (PID: %d, enfant: %d)\n", getpid(), pid);
    return (0);
}
```

**Bon courage !  ğŸ’ª**

---

